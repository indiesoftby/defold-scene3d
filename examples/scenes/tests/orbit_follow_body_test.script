go.property("acquire_input_focus", true)
go.property("key_forward", hash("key_w"))
go.property("key_backward", hash("key_s"))
go.property("key_left", hash("key_a"))
go.property("key_right", hash("key_d"))

local render3d = require("scene3d.render.render3d")

local HAS_FIXED_UPDATE = render3d.engine_version(1, 3, 1)
local APPLY_FORCE = hash("apply_force")

--- Rotate a collision object be applying opposing and offset forces
-- @param collisionobject_url
-- @param force In the format of vmath.vector3(0, force, 0)
local function apply_torque(obj_url, collisionobject_url, force)
    local rotation = go.get_rotation(obj_url)
    local world_position = go.get_world_position(obj_url)
    local offset = 0.50
    msg.post(collisionobject_url, APPLY_FORCE, { force = vmath.rotate(rotation, force), position = world_position + vmath.rotate(rotation, vmath.vector3(-offset, 0, offset)) })
    msg.post(collisionobject_url, APPLY_FORCE, { force = vmath.rotate(rotation, -force), position = world_position + vmath.rotate(rotation, vmath.vector3(offset, 0, -offset)) })
end

function init(self)
    if self.acquire_input_focus then
        msg.post(".", hash("acquire_input_focus"))
    end

    msg.post("/test_object#mesh", "disable")
end

function final(self)
end

local function do_fixed_update(self, dt)
    local sz = 0
    local sx = 0

    if self.input_key_left then
        sx = sx - 1
    end
    if self.input_key_right then
        sx = sx + 1
    end
    if self.input_key_forward then
        sz = sz + 1
    end
    if self.input_key_backward then
        sz = sz - 1
    end

    local obj_url = msg.url("/test_object")
    local collisionobject_url = msg.url("/test_object#collision")

    apply_torque(obj_url, collisionobject_url, render3d.RIGHT * -sx * 2)

    local rotation = go.get_rotation(obj_url)
    local position = go.get_position(obj_url)
    local move_force = render3d.FORWARD * sz * 20
    msg.post(collisionobject_url, APPLY_FORCE, { force = vmath.rotate(rotation, move_force), position = position })
end

function update(self, dt)
    if not HAS_FIXED_UPDATE then
        do_fixed_update(self, dt)
    end
end

function fixed_update(self, dt)
    do_fixed_update(self, dt)
end

function on_message(self, message_id, message, sender)
end

function on_input(self, action_id, action)
    if action_id == self.key_forward then
        self.input_key_forward = not action.released
    elseif action_id == self.key_backward then
        self.input_key_backward = not action.released
    elseif action_id == self.key_left then
        self.input_key_left = not action.released
    elseif action_id == self.key_right then
        self.input_key_right = not action.released
    end
end
