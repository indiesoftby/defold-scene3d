go.property("enabled", true)
go.property("camera_object_id", hash(""))
go.property("follow_object_id", hash(""))
go.property("follow_transform_interpolation", false)
go.property("interpolation_continuous_mode", false)
go.property("yaw", 0)
go.property("yaw_anim_value", 0.09)
go.property("pitch", -6)
go.property("distance", 8.15)
go.property("height", 1.9)
go.property("move_forward", 0)

go.property("late_update_priority", 1)

local math3d = require("scene3d.helpers.math3d")
local render3d = require("scene3d.render.render3d")
local transform_interpolation = require("scene3d.scripts.transform_interpolation")

local HAS_FIXED_UPDATE = render3d.engine_version(1, 3, 1)

local EMPTY_HASH = hash("")
local EULER = hash("euler")
local POSITION = hash("position")
local UPDATE_RENDER = hash("update_render")
local FORCE_UPDATE = hash("force_update")

local function lazy_init_transform(self)
    if not self.follow_transform_interpolation then
        self.follow_transform = nil
        return
    end

    if self.follow_transform then
        return
    end

    self.follow_transform = transform_interpolation.init({
        object_id = self.follow_object_id,
        continuous_mode = false,
        -- modify_transform = function (t, position, rotation)
        --     position = position + vmath.rotate(rotation, render3d.FORWARD) * self.move_forward
        --     return position, rotation
        -- end
    })
end

local function update_transform(self, dt)
    if not self.follow_transform then
        return
    end

    transform_interpolation.start_frame(self.follow_transform, dt)
end

local function interpolate_transform(self)
    if not self.follow_transform then
        return
    end

    transform_interpolation.interpolate(self.follow_transform)
end

local function update_camera(self)
    if not self.dt then
        return
    end

    if self.follow_object_id == EMPTY_HASH then
        return
    end

    if self.camera_object_id == EMPTY_HASH then
        self.warn_empty_camera_once = self.warn_empty_camera_once or (print("orbit_follow.script: set the `camera_object_id` value") or true)
        return
    end

    lazy_init_transform(self)
    interpolate_transform(self)

    local follow_rotation = self.follow_transform and self.follow_transform.rotation or go.get_rotation(self.follow_object_id)
    local follow_position = self.follow_transform and self.follow_transform.position or go.get_position(self.follow_object_id)

    -- follow_position = follow_position + vmath.vector3(3, 0, 0)

    local yaw = (90 - math3d.euler_y(follow_rotation) + self.yaw) % 360
    self.cur_yaw = math3d.lerp_angle(1 - math.exp(-4 * self.dt), self.cur_yaw or yaw, yaw)
    -- self.cur_yaw, self.cur_yaw_velocity = math3d.smooth_damp_angle(self.cur_yaw or yaw, yaw, self.cur_yaw_velocity or 0, 0.2, nil, self.dt)
    -- self.cur_yaw = yaw -- math3d.lerp_angle(interpolation_factor, a, b, dt)
    self.cur_pitch = self.pitch

    local real_yaw = (90 - math3d.euler_y(go.get_rotation(self.follow_object_id)) + self.yaw) % 360

    -- DEBUG
    -- print(render3d.frame_num .. string.format(": orbit_follow.script - update camera, real_yaw %.02f, yaw %.02f, cur_yaw %.02f, diff %.02f", real_yaw, yaw, self.cur_yaw, math3d.delta_angle(yaw, self.cur_yaw)))
    -- render3d.debug_log(string.format("dt %.05f, yaw %.02f, cur_yaw %.02f", self.dt, yaw, self.cur_yaw))

    local d = self.distance + self.move_forward
    local h = self.height
    local pos = follow_position -- + vmath.rotate(self.follow_transform.rotation, render3d.FORWARD) * self.move_forward
    pos = pos + vmath.vector3(math.cos(math.rad(self.cur_yaw)) * d, h, math.sin(math.rad(self.cur_yaw)) * d)

    local eulers = vmath.vector3(self.cur_pitch, 90 - self.cur_yaw, 0)
    go.set(self.camera_object_id, EULER, eulers)
    go.set(self.camera_object_id, POSITION, pos)
end

-- This update will happen after game objects have been moved by the physics engine
local function late_update(self)
    if not self.enabled then
        return
    end

    update_camera(self)
end

function init(self)
    self.late_update_id = scene3d.prerender_register(late_update, self.late_update_priority)

    if not self.enabled then
        return
    end

    lazy_init_transform(self)

--     local cur_velocity = 0
--     local s_y = 0
--     local dt = 1 / 60
-- 
--     local x = 0
--     local y = 0
--     for i = 1, 500 do
--         if i <= 450 then
--             x = x - 2.37
--         end
--         y = vmath.lerp(0.09, y, x)
-- 
--         s_y, cur_velocity = math3d.smooth_damp_angle(s_y, x, cur_velocity, 0.2, nil, dt)
-- 
--         print(i, string.format("%.03f", x), string.format("%.03f", y), string.format("%.03f", x - y), "SD", string.format("%.03f", s_y), string.format("%.03f", x - s_y))
--     end

    -- os.exit(1)
end

function final(self)
    scene3d.prerender_unregister(self.late_update_id)
end

function update(self, dt)
    self.dt = dt

    if not self.enabled then
        return
    end

    lazy_init_transform(self)

    if self.follow_transform then
        self.follow_transform.object_id = self.follow_object_id

        -- transform_interpolation.set_time(self.follow_transform)
    end

    if not HAS_FIXED_UPDATE then
        update_transform(self, dt)
    end
end

function fixed_update(self, dt)
    if not self.enabled then
        return
    end

    lazy_init_transform(self)
    update_transform(self, dt)
end

function on_message(self, message_id, message, sender)
    if message_id == FORCE_UPDATE then
        update_camera(self)
    end
end
