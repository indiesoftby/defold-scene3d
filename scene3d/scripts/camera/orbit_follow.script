go.property("enabled", true)
go.property("follow_object_id", hash(""))
go.property("camera_object_id", hash(""))
go.property("yaw", 0)
go.property("yaw_anim_value", 0.09)
go.property("pitch", -6)
go.property("distance", 8.15)
go.property("height", 1.9)
go.property("move_forward", 3)

go.property("late_update_priority", 1)

local math3d = require("scene3d.helpers.math3d")
local render3d = require("scene3d.render.render3d")

local EMPTY_HASH = hash("")
local EULER = hash("euler")
local POSITION = hash("position")
local UPDATE_RENDER = hash("update_render")
local FORCE_UPDATE = hash("force_update")

local function update_camera(self)
    if not self.dt then
        return
    end

    if self.follow_object_id == EMPTY_HASH then
        return
    end

    if self.camera_object_id == EMPTY_HASH then
        self.warn_empty_camera_once = self.warn_empty_camera_once or (print("orbit_follow.script: set the `camera_object_id` value") or true)
        return
    end

    local obj_rotation = go.get_rotation(self.follow_object_id)
    local obj_position = go.get_position(self.follow_object_id)

    local yaw = (90 - math3d.euler_y(obj_rotation) + self.yaw) % 360
    -- self.cur_yaw = math3d.lerp_angle(self.yaw_anim_value, self.cur_yaw or yaw, yaw)
    self.cur_yaw, self.cur_yaw_velocity = math3d.smooth_damp_angle(self.cur_yaw or yaw, yaw, self.cur_yaw_velocity or 0, 0.2, nil, self.dt)
    -- self.cur_yaw = yaw
    self.cur_pitch = self.pitch

    -- DEBUG
    print(render3d.frame_num .. string.format(": orbit_follow.script - update camera, yaw %.02f, cur_yaw %.02f, diff %.02f", yaw, self.cur_yaw, math3d.delta_angle(yaw, self.cur_yaw)))

    -- if self.dt > 0.0169 then
    --     print(render3d.frame_num .. " dt " .. self.dt)
    -- end
    render3d.debug_log(string.format("dt %.05f, yaw %.02f, cur_yaw %.02f", self.dt, yaw, self.cur_yaw))
    -- print(yaw, self.cur_yaw)

    local d = self.distance + self.move_forward
    local h = self.height
    local pos = obj_position + vmath.rotate(obj_rotation, render3d.FORWARD) * self.move_forward
    pos = pos + vmath.vector3(math.cos(math.rad(self.cur_yaw)) * d, h, math.sin(math.rad(self.cur_yaw)) * d)

    local values = vmath.vector3(self.cur_pitch, 90 - self.cur_yaw, 0)
    go.set(self.camera_object_id, EULER, values)
    go.set(self.camera_object_id, POSITION, pos)
end

-- This update will happen after game objects have been moved by the physics engine
local function late_update(self)
    if self.enabled then
        update_camera(self)
    end
end

function init(self)
    self.late_update_id = scene3d.prerender_register(late_update, self.late_update_priority)

--     local cur_velocity = 0
--     local s_y = 0
--     local dt = 1 / 60
-- 
--     local x = 0
--     local y = 0
--     for i = 1, 500 do
--         if i <= 450 then
--             x = x - 2.37
--         end
--         y = vmath.lerp(0.09, y, x)
-- 
--         s_y, cur_velocity = math3d.smooth_damp_angle(s_y, x, cur_velocity, 0.2, nil, dt)
-- 
--         print(i, string.format("%.03f", x), string.format("%.03f", y), string.format("%.03f", x - y), "SD", string.format("%.03f", s_y), string.format("%.03f", x - s_y))
--     end

    -- os.exit(1)
end

function final(self)
    scene3d.prerender_unregister(self.late_update_id)
end

function update(self, dt)
    self.dt = dt
end

function on_message(self, message_id, message, sender)
    if message_id == FORCE_UPDATE then
        update_camera(self)
    end
end
